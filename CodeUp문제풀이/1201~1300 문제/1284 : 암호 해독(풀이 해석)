#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>

int main()
{
    int n, i, p = 0, a[30] = {0}, sq, s = 0; //배열 a는 n의 약수를 저장해두는 곳. s는 배열 a의 원소 위치

    scanf("%d", &n);
    printf("<<초깃값 : n = %d, s = %d>>\n", n, s);

    //n값의 제곱근을 구해 sq에 넣음
    sq = (int)sqrt((double)n);
    //
    //해설
    // 1. 먼저 n을 입력한다
    // 2. n의 제곱근 sq를 구한다. 이걸 구하는 이유는 n의 제곱근이 k라면, k^2 = n이 될것이다. 예를 들어 25의 제곱근은 5이고, 5*5 = 25이다.
    // => 어떤값 n의 약수를 구했을때 그 약수에서 서로 대칭되는 값을 곱하게 되면 모두 n이 나오게 된다. 즉, 오름차순으로 하기 때문에 i는 작은 값부터 시작하게 된다.
    // => 그렇게 되면 절반 이상의 약수값을 가지기 전에 이미 n 을 나눌 수 있는 값이 나오기 때문이다. 그리고 n의 제곱근은 약수를 나열했을때 그 중간의 값에 위치한다.
    //i는 그렇게 n의 제곱근 값까지 루프를 돌면서, n을 i로 나눴을때의 나머지가 0인지 찾아낸다. 나머지가 0이면 i는 n의 약수가 된다.
    //3.  n에 i를 나누는 이유는 i와 그 반대편 약수값을 곱하면 n이 나오기 때문이다. (그런데 왜 n에 그 값을 대입하는 건지..) 그래서 n을 i로 나누면 그 값을 n에 넣어놓고
    // 배열 첫번째에 i를 저장해둔다. 그래서 배열에다가 약수를 저장한다.(대신 값 1은 저장해두지 않는다. 왜냐하면 while 조건문에서 i=1이면 값이 무조건 성립하기 때문이다.)
    // 그래서 배열 a에 약수 i를 저장하고, 배열위치 s를 증가시킨다. 
    // 4.for, while문에서 찾은 값으로 검사한다. n값이 1이 아니면 그 값
    //


    printf("n = %d 일때, n의 제곱근 sq = %d (i는 2~%d)\n",n,sq,sq);
    for (i = 2; i <= sq; i++)
    {
        printf("i = %d >>\n",i);
        if (n % i != 0) {
            printf("\tn %% i = %d %% %d = %d 이니 0 아님..\n", n, i,n%i);

        }
        while (n % i == 0) // 소수가 될려면 while 문이 한번만 작동해야 함. 그래야 s가 1이 되고, 밑에서 s++를 할 수 있음.
            
        {

            printf("\tn %% i = %d %% %d = 0\n", n, i);

            n /= i;  //n값으로 나누는 이유가 n을 i로 나눴을때 나머지가 0이니 그 반대편 값을 구한 것도 있지만, 그 반대편 값에서 i로 또 나눠지는 게 있다면 그 값은 소수가 아니다. 
            printf("\tn/i 실행 -> n = %d\n",n);
            a[s] = i;
            printf("\ta[%d] = %d\n", s, i);
            
            printf("\ta 배열 출력 >> ");

            for (int j = 0; j <= s; j++) {
                printf("a[%d] = %d  ", j, a[j]);
            }
            printf("\n");
            s++;
            printf("\ts++ = %d\n", s);
        }
        
    }
    //n != 1을 검사하는 이유는 n의 제곱근 값이 루트가 아닌 값일때, 즉 완전제곱수일때,(제곱수가 정수값을 가지는 수) 위 while문에서 완전제곱수를 나눌때 
    // 만약 25이면 i가 5일때 n = 5가 될꺼고 또 i=5로 나눠지니까 n=1, s =2가 된다. 약수가 2개가 있는데 이걸 n!=1를 조건을 걸지 않게 되면 s가 증가된다.
    // 만약 26이면 i가 2일때 n= 13가 될꺼고 i로 나눠지지 않으니 n=13,s=1가 된다. n!=1이니 s=2가 된다.
    // if (n != 1) 과 if (s == 2)를 하는 이유가 완전제곱수가 아닌 값들은 s 증가를 시키고, 완전제곱수는 s를 증가시키지 않는다. 
    // 그래서 소수인 두 값이 나올려면 s == 2가 되야함. 배열에 넣는 값이 2개만 되야 함. 배열에 들어가는 값이 3개가 된다면 두 약수값 중 하나가 나눠졌다는
    // 뜻이니 그 값들은 소수가 아니게 된다.
    // 
    // n 이 1이 아니면 n을 i로 나눈 값 n을 포함하기 위해 a[s]에 n을 넣고 s를 증가시킴
    if (n != 1) { a[s] = n, s++; printf("\na[%d] = %d != 1 이니 a[%d] = %d, s++ = %d\n",s, n, s, n, s); }
    //s가 2이면 이것은 1과 자기자신을 포함한 것이니 a[0] 과 a[1]은 소수임.
    if (s == 2) printf("s = %d == 2이니  a[0],a[1] -> %d %d\n",s, a[0], a[1]);
    //s가 2보다 큰 경우(두 약수 중 나눠지는 값이 있는 경우) , s = 1인 경우(n = 2), s = 0인 경우(n = 1, n이 소수인 경우) 
    else puts("wrong number");
}
/*
38
<<초깃값 : n = 38, s = 0>>
n = 38 일때, n의 제곱근 sq = 6 (i는 2~6)
i = 2 >>
        n % i = 38 % 2 = 0
        n/i 실행 -> n = 19
        a[0] = 2
        a 배열 출력 >> a[0] = 2
        s++ = 1
i = 3 >>
        n % i = 19 % 3 = 1 이니 0 아님..
i = 4 >>
        n % i = 19 % 4 = 3 이니 0 아님..
i = 5 >>
        n % i = 19 % 5 = 4 이니 0 아님..
i = 6 >>
        n % i = 19 % 6 = 1 이니 0 아님..

a[2] = 19 != 1 이니 a[2] = 19, s++ = 2
s = 2 == 2이니  a[0],a[1] -> 2 19
*/
